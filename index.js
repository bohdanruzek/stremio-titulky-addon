require('dotenv').config();
const { addonBuilder } = require('stremio-addon-sdk');
const axios = require('axios');
const puppeteer = require('puppeteer');
const express = require('express');
const path = require('path');
const fs = require('fs');
const os = require('os');

// Konfigurace
const PORT = process.env.PORT || 7000;
const OMDB_API_KEY = '96c2253d';

// Z√≠sk√°n√≠ lok√°ln√≠ IP adresy
function getLocalIP() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      if (iface.family === 'IPv4' && !iface.internal) {
        return iface.address;
      }
    }
  }
  return 'localhost';
}

const LOCAL_IP = getLocalIP();
const BASE_URL = process.env.BASE_URL || `http://${LOCAL_IP}:${PORT}`;

// Vytvo≈ôen√≠ slo≈æky pro titulky
const subsDir = path.join(__dirname, 'subs');
if (!fs.existsSync(subsDir)) {
  fs.mkdirSync(subsDir);
}

// Beast Mode Manifest
const manifest = {
  id: 'community.titulkycom.beast',
  version: '2.0.0',
  name: 'Titulky.com BEAST MODE ü§ñ',
  description: '8GB Puppeteer power - Anti-bot? What anti-bot?',
  resources: ['subtitles'],
  types: ['movie'],
  idPrefixes: ['tt'],
  catalogs: []
};

// ƒåi≈°tƒõn√≠ n√°zvu
function cleanTitle(title) {
  return title
    .replace(/[^\w\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase();
}

// OMDB funkce
async function getMovieInfo(imdbId) {
  try {
    const response = await axios.get(`http://www.omdbapi.com/?i=${imdbId}&apikey=${OMDB_API_KEY}`);
    return response.data;
  } catch (error) {
    console.error('‚ùå OMDB chyba:', error.message);
    return null;
  }
}

// ü§ñ PUPPETEER BEAST MODE - 8GB EDITION ü§ñ
async function beastModeSearch(movieTitle, movieYear) {
  let browser;
  try {
    console.log(`ü§ñ BEAST MODE: Spou≈°t√≠m Chrome pro "${movieTitle}"`);
    console.log(`üí™ 8GB RAM: Anti-bot ochrana se m≈Ø≈æe b√°t!`);
    
    // Launch Chrome s beast mode configem
    browser = await puppeteer.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--no-first-run',
        '--no-zygote',
        '--disable-gpu',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding',
        '--disable-features=TranslateUI',
        '--disable-ipc-flooding-protection',
        '--memory-pressure-off'
      ],
      defaultViewport: { width: 1920, height: 1080 }
    });

    const page = await browser.newPage();
    
    // Advanced stealth mode
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
    await page.setViewport({ width: 1920, height: 1080 });
    
    // Anti-detection
    await page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, 'webdriver', {
        get: () => undefined,
      });
    });

    console.log(`üåê BEAST: √ötoƒç√≠m na titulky.com`);
    await page.goto('https://www.titulky.com/', { 
      waitUntil: 'networkidle2',
      timeout: 45000 
    });

    // ƒåekej chvilku na naƒçten√≠
    await page.waitForTimeout(2000);

    console.log(`üîç BEAST: Analyzujem str√°nku pro "${movieTitle}"`);
    
    // Najdi filmy na hlavn√≠ str√°nce
    const movieMatches = await page.evaluate((title, year) => {
      const matches = [];
      
      // Hledej v r≈Øzn√Ωch sekc√≠ch
      const selectors = [
        'a[href*=".htm"]',
        '.movie-link',
        'tr a',
        'td a'
      ];
      
      selectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(element => {
          const text = element.textContent.trim();
          const href = element.href;
          
          if (text && href && href.includes('.htm')) {
            const lowerText = text.toLowerCase();
            const lowerTitle = title.toLowerCase();
            
            // Fuzzy matching
            if (lowerText.includes(lowerTitle) || 
                lowerTitle.includes(lowerText.split(' ')[0]) ||
                lowerText.includes(year)) {
              matches.push({
                text: text,
                url: href,
                score: lowerText.includes(lowerTitle) ? 100 : 50
              });
            }
          }
        });
      });
      
      // Se≈ôaƒè podle score
      return matches.sort((a, b) => b.score - a.score);
    }, movieTitle, movieYear);

    console.log(`üìã BEAST: Nalezeno ${movieMatches.length} potenci√°ln√≠ch film≈Ø`);

    if (movieMatches.length === 0) {
      console.log(`‚ùå BEAST: ≈Ω√°dn√© filmy nenalezeny`);
      return [];
    }

    // Zkus prvn√≠ 2 nejlep≈°√≠ matches
    for (let i = 0; i < Math.min(movieMatches.length, 2); i++) {
      const match = movieMatches[i];
      console.log(`üéØ BEAST: Testujem match ${i+1}: ${match.text}`);
      
      try {
        // Jdi na str√°nku filmu
        await page.goto(match.url, { 
          waitUntil: 'networkidle2',
          timeout: 30000 
        });

        console.log(`üîç BEAST: Hled√°m download tlaƒç√≠tko`);
        await page.waitForTimeout(1000);

        // Najdi download button - zkus v√≠ce selektor≈Ø
        const downloadFound = await page.evaluate(() => {
          const selectors = [
            'a[href*="download"]',
            'a[href*=".zip"]',
            'a[href*=".rar"]',
            '.download',
            '#download',
            'a:contains("St√°hnout")',
            'a:contains("Download")'
          ];
          
          for (const selector of selectors) {
            try {
              const element = document.querySelector(selector);
              if (element) {
                return { found: true, selector: selector };
              }
            } catch (e) {}
          }
          
          // Fallback - hledej text
          const links = document.querySelectorAll('a');
          for (const link of links) {
            const text = link.textContent.toLowerCase();
            if (text.includes('st√°hnout') || text.includes('download') || 
                text.includes('zip') || text.includes('rar')) {
              return { found: true, element: link.href };
            }
          }
          
          return { found: false };
        });

        if (!downloadFound.found) {
          console.log(`‚ùå BEAST: Download tlaƒç√≠tko nenalezeno pro ${match.text}`);
          continue;
        }

        console.log(`üéØ BEAST: Download tlaƒç√≠tko nalezeno!`);

        // Klikni na download
        await page.click('a[href*="download"], a[href*=".zip"], a[href*=".rar"]');
        
        console.log(`‚è∞ BEAST: ƒåek√°m na countdown (15 sekund)...`);
        console.log(`üí™ 8GB RAM: M≈Ø≈æu si dovolit ƒçekat!`);
        
        // Poƒçkej na countdown s extra ƒçasem
        await page.waitForTimeout(15000);

        console.log(`üîç BEAST: Hled√°m fin√°ln√≠ download link`);

        // Zkus naj√≠t fin√°ln√≠ download
        const finalDownload = await page.evaluate(() => {
          const finalSelectors = [
            'a[href*=".zip"]:not([href*="download.php"])',
            'a[href*=".rar"]:not([href*="download.php"])',
            'a[download]',
            '.final-download',
            '#final-download'
          ];
          
          for (const selector of finalSelectors) {
            const element = document.querySelector(selector);
            if (element && element.href) {
              return element.href;
            }
          }
          
          // Backup - hledej v current URL
          if (window.location.href.includes('.zip') || 
              window.location.href.includes('.rar')) {
            return window.location.href;
          }
          
          return null;
        });

        if (finalDownload) {
          console.log(`üíæ BEAST: Fin√°ln√≠ download nalezen: ${finalDownload}`);
          
          // St√°hni soubor
          const downloadPage = await browser.newPage();
          const response = await downloadPage.goto(finalDownload, {
            waitUntil: 'networkidle2',
            timeout: 30000
          });

          if (response && response.ok()) {
            const buffer = await response.buffer();
            const fileName = `${cleanTitle(movieTitle)}_beast_${Date.now()}`;
            
            // Detekce typu souboru
            let ext = '.zip';
            const contentType = response.headers()['content-type'];
            if (contentType) {
              if (contentType.includes('zip')) ext = '.zip';
              else if (contentType.includes('rar')) ext = '.rar';
              else if (contentType.includes('text')) ext = '.srt';
            }
            
            const filePath = path.join(subsDir, fileName + ext);
            fs.writeFileSync(filePath, buffer);
            console.log(`üíæ BEAST: Soubor ulo≈æen: ${filePath}`);

            // Pokus o rozbalen√≠
            if (ext === '.zip') {
              try {
                const AdmZip = require('adm-zip');
                const zip = new AdmZip(filePath);
                const entries = zip.getEntries();
                
                for (const entry of entries) {
                  if (entry.entryName.endsWith('.srt') || entry.entryName.endsWith('.sub')) {
                    const extractPath = path.join(subsDir, `${fileName}.srt`);
                    fs.writeFileSync(extractPath, entry.getData());
                    console.log(`üìÇ BEAST: Rozbaleno: ${extractPath}`);
                    
                    await downloadPage.close();
                    
                    return [{
                      id: `beast_mode_${Date.now()}`,
                      url: `${BASE_URL}/subtitles/${fileName}.srt`,
                      lang: 'cze'
                    }];
                  }
                }
              } catch (zipError) {
                console.log(`‚ö†Ô∏è BEAST: ZIP chyba, zkou≈°√≠m jako SRT`);
              }
            }
            
            // Fallback - rename to SRT
            const srtPath = path.join(subsDir, `${fileName}.srt`);
            try {
              fs.renameSync(filePath, srtPath);
              console.log(`‚úÖ BEAST: P≈ôejmenov√°no na SRT: ${srtPath}`);
              
              await downloadPage.close();
              
              return [{
                id: `beast_mode_${Date.now()}`,
                url: `${BASE_URL}/subtitles/${fileName}.srt`,
                lang: 'cze'
              }];
            } catch (renameError) {
              console.log(`‚ùå BEAST: Chyba p≈ôejmenov√°n√≠: ${renameError.message}`);
            }
          }
          
          await downloadPage.close();
        } else {
          console.log(`‚ùå BEAST: Fin√°ln√≠ download link nenalezen`);
        }

      } catch (matchError) {
        console.error(`‚ùå BEAST: Chyba p≈ôi zpracov√°n√≠ ${match.text}:`, matchError.message);
        continue;
      }
    }

    console.log(`‚ùå BEAST: V≈°echny pokusy selhaly`);
    return [];

  } catch (error) {
    console.error(`‚ùå BEAST MODE ERROR: ${error.message}`);
    return [];
  } finally {
    if (browser) {
      await browser.close();
      console.log(`üîí BEAST: Chrome browser uzav≈ôen`);
    }
  }
}

// Hlavn√≠ funkce
async function getSubtitles(type, id) {
  try {
    console.log(`üé¨ BEAST MODE: Zpracov√°v√°m ${type} s ID: ${id}`);
    
    const movieInfo = await getMovieInfo(id);
    if (!movieInfo || movieInfo.Response === 'False') {
      console.log('‚ùå Film nenalezen v OMDB');
      return [];
    }

    console.log(`üé≠ BEAST: Nalezen film: ${movieInfo.Title} (${movieInfo.Year})`);
    console.log(`ü§ñ BEAST: Spou≈°t√≠m 8GB Puppeteer √∫tok!`);

    const subtitles = await beastModeSearch(movieInfo.Title, movieInfo.Year);
    
    if (subtitles.length > 0) {
      console.log(`üéâ BEAST MODE √öSPƒöCH: ${subtitles.length} titulk≈Ø nalezeno!`);
    } else {
      console.log(`üò§ BEAST MODE: Ani 8GB nestaƒçilo...`);
    }

    return subtitles;

  } catch (error) {
    console.error('‚ùå BEAST: Celkov√° chyba:', error.message);
    return [];
  }
}

// Addon builder
const builder = addonBuilder(manifest);

builder.defineSubtitlesHandler(async ({ type, id }) => {
  console.log(`üì• BEAST REQUEST: ${type}/${id}`);
  
  try {
    const subtitles = await getSubtitles(type, id);
    return { subtitles };
  } catch (error) {
    console.error('‚ùå BEAST handler chyba:', error.message);
    return { subtitles: [] };
  }
});

// Express server
const app = express();

// CORS
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

// Cache busting
app.use((req, res, next) => {
  res.header('Cache-Control', 'no-cache, no-store, must-revalidate');
  res.header('Pragma', 'no-cache');
  res.header('Expires', '0');
  next();
});

// Debug middleware
app.use((req, res, next) => {
  if (req.url.includes('/subtitles')) {
    console.log(`üî• BEAST SUBTITLES REQUEST: ${req.method} ${req.url}`);
  }
  next();
});

// Static files
app.use('/subtitles', express.static(subsDir));

// Routes
app.get('/', (req, res) => {
  res.send(`
    ü§ñ BEAST MODE ADDON ü§ñ
    <br>üí™ 8GB RAM Power
    <br>üéØ Anti-bot? What anti-bot?
    <br>üî• Titulky.com has no chance!
  `);
});

app.get('/manifest.json', (req, res) => {
  console.log('üìã BEAST: Manifest po≈æadavek');
  res.json(manifest);
});

// Main endpoint
app.get('/subtitles/:type/:id/:filename', async (req, res) => {
  try {
    const { type, id } = req.params;
    console.log(`ü§ñ BEAST FORMAT: type=${type}, id=${id}`);
    const subtitles = await getSubtitles(type, id);
    console.log(`‚úÖ BEAST: Returning ${subtitles.length} subtitles`);
    res.json({ subtitles });
  } catch (error) {
    console.error('‚ùå BEAST endpoint chyba:', error);
    res.json({ subtitles: [] });
  }
});

// Fallback
app.get('/subtitles/:type/:id', async (req, res) => {
  try {
    const { type, id } = req.params;
    console.log(`ü§ñ BEAST FALLBACK: type=${type}, id=${id}`);
    const subtitles = await getSubtitles(type, id);
    res.json({ subtitles });
  } catch (error) {
    console.error('‚ùå BEAST fallback chyba:', error);
    res.json({ subtitles: [] });
  }
});

// Start the BEAST
app.listen(PORT, () => {
  console.log(`üöÄ BEAST MODE ADDON bƒõ≈æ√≠ na portu ${PORT}`);
  console.log(`ü§ñ 8GB RAM: Ready to destroy anti-bot protection!`);
  console.log(`üí™ Puppeteer: Loaded and dangerous!`);
  console.log(`üéØ Target: titulky.com countdown system`);
  console.log(`üî• Manifest: ${BASE_URL}/manifest.json`);
  
  if (process.env.BASE_URL) {
    console.log(`üåê BEAST URL: ${process.env.BASE_URL}`);
  }
  
  console.log(`\nü§ñ BEAST MODE ACTIVATED! ü§ñ`);
});

module.exports = builder.getInterface();
